//
// User.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct User: Codable, JSONEncodable, Hashable {

    public enum Policy: String, Codable, CaseIterable {
        case anonymuser = "anonymUser"
        case adminuser = "adminUser"
    }
    static let sidRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^[0-9a-fA-F]{24}$/")
    static let channelRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^[0-9a-fA-F]{24}$/")
    static let idRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^[0-9a-fA-F]{24}$/")
    public var secondary: String?
    public var secondaryIds: [String]?
    /** Refers to UserSession */
    public var sid: String?
    public var lastEventDate: Date?
    public var policy: Policy? = .anonymuser
    public var isAnonym: Bool? = true
    public var appliedDsgvoDataPrivacyRules: [AnyCodable]?
    public var username: String?
    public var password: String?
    public var email: String?
    /** Refers to Channel */
    public var channel: String?
    public var secret: String?
    public var lastLoginDate: Date? = Date(timeIntervalSince1970: 1690373602176000.0 / 1_000_000)
    public var id: String?
    public var createdAt: Date?
    public var updatedAt: Date?

    public init(secondary: String? = nil, secondaryIds: [String]? = nil, sid: String? = nil, lastEventDate: Date? = nil, policy: Policy? = .anonymuser, isAnonym: Bool? = true, appliedDsgvoDataPrivacyRules: [AnyCodable]? = nil, username: String? = nil, password: String? = nil, email: String? = nil, channel: String? = nil, secret: String? = nil, lastLoginDate: Date? = Date(timeIntervalSince1970: 1690373602176000.0 / 1_000_000), id: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
        self.secondary = secondary
        self.secondaryIds = secondaryIds
        self.sid = sid
        self.lastEventDate = lastEventDate
        self.policy = policy
        self.isAnonym = isAnonym
        self.appliedDsgvoDataPrivacyRules = appliedDsgvoDataPrivacyRules
        self.username = username
        self.password = password
        self.email = email
        self.channel = channel
        self.secret = secret
        self.lastLoginDate = lastLoginDate
        self.id = id
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case secondary
        case secondaryIds
        case sid
        case lastEventDate
        case policy
        case isAnonym
        case appliedDsgvoDataPrivacyRules
        case username
        case password
        case email
        case channel
        case secret
        case lastLoginDate
        case id = "_id"
        case createdAt
        case updatedAt
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(secondary, forKey: .secondary)
        try container.encodeIfPresent(secondaryIds, forKey: .secondaryIds)
        try container.encodeIfPresent(sid, forKey: .sid)
        try container.encodeIfPresent(lastEventDate, forKey: .lastEventDate)
        try container.encodeIfPresent(policy, forKey: .policy)
        try container.encodeIfPresent(isAnonym, forKey: .isAnonym)
        try container.encodeIfPresent(appliedDsgvoDataPrivacyRules, forKey: .appliedDsgvoDataPrivacyRules)
        try container.encodeIfPresent(username, forKey: .username)
        try container.encodeIfPresent(password, forKey: .password)
        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(channel, forKey: .channel)
        try container.encodeIfPresent(secret, forKey: .secret)
        try container.encodeIfPresent(lastLoginDate, forKey: .lastLoginDate)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(updatedAt, forKey: .updatedAt)
    }
}

